%
%       the build system manual
%

\documentclass[a4paper]{article}
\usepackage{a4wide}%      from ctan macros/latex/contrib/other/misc/a4wide.sty
\usepackage{url}%         from ctan macros/latex/contrib/other/misc/url.sty
\usepackage{epsfig}%      part of the latex graphics packge
\usepackage{html}

% see ftp://ftp.tex.ac.uk/tex-archive/CTAN.sites for ctan sources

%
% process checkin information; this stupid performance allows us to
% define a macro whose argument specification allows it gobble rcs
% information, without actually being hacked by rcs itself
%
\def\dollarcharacter{$}
\edef\defrcsid{%
  \def\noexpand\rcsid\dollarcharacter Id: ##1 ##2 ##3/##4/##5 ##6 ##7 ##8${%
    \gdef\noexpand\checkindate{##3/##4/##5}%
    \gdef\noexpand\checkinauthor{##7}%
    \gdef\noexpand\checkinversion{##2}%
  }
}
\defrcsid

% this is the line that gets hacked by rcs

\rcsid $Id: build-manual.tex 1.1 Tue, 13 Apr 1999 14:06:13 +0100 dr10009 $

%
% distinguish between various uses of url package commands, etc.
%
\newcommand{\cmd}[1]{\texttt{#1}}
\newcommand{\file}  {\begingroup \urlstyle{tt}\Url}
\newcommand{\dir}   {\begingroup \urlstyle{tt}\Url}
\newcommand{\script}{\begingroup \urlstyle{tt}\Url}

%
% This allows large portions of space to be used by floats
%
\renewcommand{\topfraction}{.9}
\renewcommand{\bottomfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\floatpagefraction}{.9}

\title{The Nemesis Build System\\
  Users' Guide and Reference Manual\\
  7th Edition\thanks{Revision date 1999/04/08, last checkin
    r\checkinversion, \checkindate\ by \checkinauthor}}
\date{April 1999\thanks{Processed \today}}
\author{Dickon Reed}
\def\shellcom#1{ \begin{quote} {\footnotesize \$ #1 } \end{quote}}

\begin{document}
\begin{rawhtml}
<BODY BGCOLOR="#FFFFFF">
\end{rawhtml}
\begin{rawhtml}
<a href="/Research/SRG/pegasus/nemesis/documentation.html">
Documentation index </a>
\end{rawhtml}
\maketitle
\tableofcontents

This manual takes off where the release notes finish. Please refer to
the Nemesis release notes first to discover how to obtain Nemesis.

\section{Introduction}

The Nemesis build system and source code management are quite
complicated and may be quite different from what you are used to. Once
learnt, however, it is very flexible and powerful, and quite fast.

The release notes describe the use of the quickstart tar ball method
of building Nemesis. I suggest you try this first; for some purposes,
it is sufficient, and it has been made as easy to use as
possible. You will probably rapidly tire of downloading new quickstart
tar balls, however. Also, to introduce new programs you need to learn
how to drive the build system.

We now use PRCS to control Nemesis source code management. We use PRCS
to checkout code, merge our working trees and perform diffs to
generate patches. However, all changes go through the dpatch system,
which makes checking changes easier and enables efficient distribution
of patches.

We have a tool called checkoutandgo.py (in \dir{misc/scripts} in the
quickstart tarball and releasemisc package). It will handle the checking
out of Nemesis code and the construction of build trees for you
automatically. It is not actually Nemesis specific. It has its own
documentation embedded as a large string in the checkoutandgo.py file
itself, which you may like to inspect. The quickstart tar ball, for
instance, is generated by checkoutandgo.py from the PRCS archive, with
a short configuration file which at the time of writing looked like
this:

\begin{verbatim}
{
  'packages' : [
     ('copy', '/usr/groups/pegasus/nemesis/releasemisc', ''),
     ('prcs', 'ccore:live.@', '/nemesis'),
     ('prcs', 'cnet:live.@', '/nemesis'),
     ('prcs', 'cws:live.@', '/nemesis'),
     ('prcs', 'caudio:live.@', '/nemesis'),
     ('prcs', 'cfs:live.@', '/nemesis'),
     ('prcs', 'catm:live.@', '/nemesis'),
     ('prcs', 'tgtx86:live.@', '/nemesis'),
     ('prcs', 'nemtools:live.@', '/tools/source'),
     ('prcs', 'dpatch:live.@', '/dpatch'), 
   ],
  'basepath' : '/anfs/scratch/hornet/dr10009/autobuild/cuttingedge',
  'actions' : """
make docs
make README.html
make image
make bootloader
echo "warning; not testing the image"
make dist
cp ../quickstart.tar.gz /usr/groups/pegasus/nemesis/quickstart.tar.gz
echo "lock and load"
""",
  'prcsrepo' : '/local/scratch/dr10009/nemesis/PRCS',
  'prcspath' : '/homes/dr10009/bin/ix86_linux/prcs',
  'postfix' : 'release'
}
\end{verbatim}

The packages section specifies what should go in to the directory
specified by the basepatch section, with the postfix release. You can
see the PRCS version IDs for each package; they could be changed to
specify other branches and versions if we wanted to.

The release notes gives another example, for day to day construction
of Nemesis build trees. That example introduces the concept of a
choices file, discussed in the next section.

\subsection{The quickstart shortcuts}

When we released Nemesis, we wanted to make things as easy to use as
possible. Therefore, there are a couple of simple scripts in the
releasemisc package that end up in the root of quickstart tar
ball. One is a Makefile, the other a python script called
quickbuild.py. Here are some things that they can be used for:

\begin{itemize}

\item Automatically building a tools tree and a Nemesis tree.

\begin{verbatim}
make
\end{verbatim}

ie you can just go untar; make and it should work.

\item Making a boot floppy for Nemesis. Unpack a quickstart tarball or
use checkoutandgo.py yourself, put a floppy disk in to your drive and
type:

\begin{verbatim}
make bootfloppy
\end{verbatim}

\item Clean up a tree (used after testing a tree to make the
quickstart tar ball).

\begin{verbatim}
make clean
\end{verbatim}

\item Generate the documentation

\begin{verbatim}
make docs
\end{verbatim}

\item Create and build an intel tree

\begin{verbatim}
make intel
\end{verbatim}

eb164 and shark will also work if tgtalpha or tgtarm are available.

\item Create an intel tree

\begin{verbatim}
quickbuild.py establish-intel
\end{verbatim}

Same as make intel, but don't build tree tree immediately. Useful so
that the choices file can be edited and then the make done manually.

\begin{verbatim}
quickbuild.py tools ix86_linux_rh5.1
\end{verbatim}

Build the Nemesis tools for Redhat 5.1. If you leave out the last
argument, quickbuild will attempt to figure things out for you
automatically.

\end{itemize}


\subsection{Configuring your build tree}
Out of the box, as described above, Nemesis should have a fairly
sensible configuration. However, Nemesis is very flexible, and the
build system may be configured in many interesting ways. In the build
directory (\dir{nemesis/build_intel} for instance) you should find a file
called \script{choices}. You can edit this to file to reconfigure that
build tree. Then, in that same directory, with the Nemesis tools on
your path, you can type:

\begin{verbatim}
$ make grow
$ make
\end{verbatim}

to configure the tree with your changes. The make grow part will
create or change symlinks as a result of what is in your choices file.

The language you should use to write your choices file is described in
detail in this document, but here are some common examples.

To add your own source code to the tree without changing the master
tree (so you can share the master tree and so you can keep your source
code on a backed up disk without having to back up the master tree):

\begin{verbatim}
add_source_tree('/usr/groups/pegasus/users/dr10009/nemx')
\end{verbatim}

The second checkoutandgo example in the release notes does something
like this automatically when establishing a build tree.  The
checkoutandgo configuration file was:

\begin{verbatim}
{
  'packages' : [
     ('prcs', 'releasemisc:live.@', ''),
     ('prcs', 'ccore:live.@', '/nemesis'),
     ('prcs', 'cnet:live.@', '/nemesis'),
     ('prcs', 'cws:live.@', '/nemesis'),
     ('prcs', 'caudio:live.@', '/nemesis'),
     ('prcs', 'cfs:live.@', '/nemesis'),
     ('prcs', 'tgtx86:live.@', '/nemesis'),
   ],
  'basepath' : '/anfs/scratch/hornet/dr10009/autobuild/cuttingedge',
  'actions' : """
python quickbuild.py establish-intel
echo "add_source_tree('~/mysparsetree')" >> choices
cd nemesis/build_intel
make grow
make
""",
  'prcsrepo' : '/local/scratch/dr10009/nemesis/PRCS',
}
\end{verbatim}

The actions script here does three things:

\begin{enumerate}
\item Create a build tree (and the choices file as part of that) for
intel.
\item Add an add source tree command to the end of the choices file.
\item Enter the build tree and grow and build it.
\end{enumerate}

You could leave some of these actions and do the same thing manually
of course.

You can create files and directories in the directory specified (you
should pick your own), and they will be substituted for the standard
files in the nemesis/master directory whenever you type \texttt{make
grow}.

\section{Build system overview}

At the centre of the build system is a database, called the blueprint,
that contains a large amount of data about how to build Nemesis.
Python scripts process this data in order to perform all the necessary
work to set up a tree to be built.  Building Nemesis is not performed
in the master tree itself as it would do normally, but rather in
\emph{build trees}. \cmd{gnumake} is used to control the build process
itself, but a number of python tools are used to set up a tree for
\cmd{gnumake} to build in. Build trees may be regarded as volatile and
need not backed up; no source code should be stored there.

The blueprint database is split between a number of package files, in
the subdirectory glue/packages. Every .py file in there is assumed to
be a list of blueprint items, corresponding to one of the
packages. There is no ordering on blueprint items. The
\script{glue/customizer.py} interprets the choices file to specialize
the database for one particular build.
The customizer works in
two ways; firstly, it specializes the blueprint to be unique to the
particular target machine specified in the file
(\script{glue/treeinfo.py}) in a build tree.  Secondly, it processes the
file \file{choices} in the root of the build tree, where the user can
place configuration tweaks, overrides, extra build items and
instructions to include \url{choices} files from other places, and packages.
The customizer is invoked quite often, whenever data about the tree is
required so that the build tree may be manipulated.

The program \script{glue/layfoundations.py} contains the code to
create a build tree. It will create the build tree directory, the file
\script{glue/treeinfo.py} using the command line arguments specified,
the file \file{choices} and symlink the files in the source tree(s)
over to the build tree. Then, the user may execute \cmd{gnumake} at
the root of the build tree.  Various python scripts will be invoked to
derive further information about the tree, as necessary, automatically
by \cmd{gnumake}.

%The program \script{glue/changefoundations.py} is really a symbolic link
%in the build tree to \script{glue/layfoundations.py}. It is used to
%request parts of the procedure employed by layfoundations to be
%repeated. The command \cmd{gnumake itso} invokes
%\script{changefoundations.py} to 
%do whatever can safely be repeated of the layfoundations procedure, to
%the entire tree. It can only be run in the root of the build tree. The
%command \cmd{gnumake grow} however can be run in any subdirectory of the
%tree (that has a \file{Makefile}). It will add whatever files are necessary
%to that subdirectory and below, and will update the auto generated
%makefiles to reflect any new directories.

Once a build tree has been established, the command \cmd{gnumake audit}
in the root of the build tree should produce on stdout a list of all
the configuration options and their current values. Furthermore, the
output is in a format where it can be fed back in to the build system
as a choices file.

The \script{glue/choicesgui.py} file contains a Python GTK based user
interface for editing the \url{choices} files. It is optional, and
will require additional Python libraries to work, but enables the
\url{choices} file to be easily edited. (It is old and may not work
anymore without some reworking. It predates packages, for instance).


The blueprint and choices file together can be used by
\script{glue/regenerate_packages.py} to autogenerate a replacement set
of package files that can then be moved back in to a source tree,
incorporating the changes mentioned in the \file{choices} file.

\section{Important directories in the build tree}

\begin{description}
\item[The root] of the build tree contains a makefile that can be
invoked to build the tree. It also contains the file \url{choices},
that should be edited by users in order to customize the behaviour of
the build tree. See the section on choices below. 

\item[glue] contains all the python scripts used to drive the build
system, together with a couple of database files---%
\url{glue/generic_blueprint.py} and \url{glue/treeinfo.py} which
should not normally need to be edited by the user.

\item[boot/images] contains a directory named after the target where
the bootable image will appear.

\item[repo] is responsible for building all the ``system'' interfaces---%
those which are available throughout the tree and will be in the
Nemesis type system from the start of day.

\item[links] is where symbolic links to the rest of the build tree
appear. If your build tree and source tree are readable from the NFS
server serving files to your Nemesis box, then it is sufficient to
make this directory the boot directory of the Nemesis box. Otherwise,
you will need to copy the contents of this directory on to your NFS server.
\end{description}

\section{Choices}

There are two common ways that a Nemesis build tree can be
modified. Firstly, the user can change the tree configuration in the
\url{choices} file. Secondly, the user can write or modify source code
and arrange for this to be built in place of some of the source code
in the master tree.

The \url{choices} file is a human readable ASCII text file, located in the
root of the build tree. It should be treated as source code; it is
sensible to symbolically link it from a backed up partition.
Multiple build trees can share a choices file. Without
a choices file, the build system sticks to the defaults specified in
the file \url{glue/generic_blueprint.py}. The Choices GUI allows the
\url{choices} file to be edited without the user having to understand too
much about the \url{choices} file syntax and Nemesis. It allows more
experienced users to edit the \url{choices} file interactively with
reference to the blueprint database. See the next section for
instructions on using the Choices GUI.

\subsection{Quad choices}

The simplest thing one can do in the choices file is to modify the
status of one of the build items. For a program or module, this will
change the level of support for a build item. The levels are:

\begin{itemize}
\item[0] Nothing to do with the item is incorporated in to the
system. (Symbolic name; NONE or~N)

\item[1] Interfaces used by the item are built and incorporated in to
the system. This makes it easier to add the item later. (Symbolic
name; SUPPORT or~S).

\item[2] The item is built, and a symbolic link is created for it in
the \url{links} directory, but it is not placed in the boot image. This is
default for some things that are normally dynamically loaded. (Symbolic
name; BUILD or~B).

\item[3] The item is built and placed in to the boot image. No symbolic
link will be added to the \url{links} directory, since it is in the
boot image and does not need to be dynamically loaded. (Symbolic name; NBF
or~Y).
\end{itemize}

The symbolic names may be used, inside quotes, instead of the numbers.
Here are some example lines that could be added to a choices file that
set one of these quad-level options:

\begin{verbatim}
set('carnage','BUILD')
\end{verbatim}

This causes the Nemesis demo application ``carnage'' to be built and
made available for dynamic loading.

\begin{verbatim}
set('fbs3',3)
\end{verbatim}

This causes the S3 framebuffer device driver to be placed in to the
boot image, to avoid having to dynamically load it. 

\begin{verbatim}
set('Spawn','N')
\end{verbatim}

This causes the Spawn module to be completely ignored by the build
tree. This may have a knock on effect on some other parts of the build
tree, causing things you might not expect to stop working, since they use
Spawn.

\subsection{Boolean choices}

There are a few build items that have boolean choice options
associated with them. These may be set in a similar way to quad
choices, use one of 0, N, NO, FALSE or F to turn an option off, or 1,
Y, YES, TRUE or T to turn an option on. For example, to disable the
backdrop loading code in the Nemesis windowing system, one could
write:

\begin{verbatim}
set('backdrop','NO')
\end{verbatim}

In general, the set command takes an item name in either single or
double quotes as the first argument, and either a numeric or string
value as the second argument.

\subsection{Selection choices}

There are a few item that take special second argument names. For
example, to select the experimental memory system and binder, one
could add:

\begin{verbatim}
set('memsys', 'EXPT')
set('binder', 'MUX')
\end{verbatim}

\subsection{Including other choices files and so packages}

To include a new choices file, the full path name of the choices file
should be specified in an \texttt{include} command. For example:

\begin{verbatim}
include('/usr/groups/pegasus/users/dr10009/packages/audio/package')
\end{verbatim}

\noindent causes the build system to read the specified file and
interpret it as a choices file. 

A package is a collection of source files and a choices file that adds
them to a certain version of Nemesis. The example above actually adds
an experimental audio package to a Nemesis build tree.

\subsection{Adding programs and modules}

To add a new program or module to the system, merely write something
like one of the following lines:

\begin{verbatim}
add_program('app/tone/testtone')
add_module('mod/aubuf/aubuf')
\end{verbatim}

You must type \cmd{gnumake grow} for these things to appear in your build
tree; they must be in the source tree or wherever you have relocated
them using the \url{reloc} command at this point. \cmd{gnumake grow}
will cause any directories necessary to be created and makefiles to be
created or updated. If you then remove the lines from choices,
\cmd{make grow} will put the makefiles modified to mention the new
directories back again. You only need to run \cmd{gnumake grow} in the
directories that have been affected---in the above cases, \url{app} and
\url{mod}. Note that the parent directory of one you modify must be
changed; it would not be sufficient to run \cmd{gnumake grow} in
\url{app/tone}, because this would not update \url{app/Makefile}. 

By default, programs are set to  level 2 support (i.e., built but not
placed in the boot image) whereas modules are set to level 3 support (i.e.,
built and placed in the boot image). \url{set} commands may precede
\url{add_} commands, in order to override these defaults. For example:

\begin{verbatim}
add_program('dev/pci/3dfx/3dfxdriver')
set('3dfxdriver', 'NBF')
\end{verbatim}

(Note that the item name of an added program or module is the final
component of its filename).

\subsection{Adding and deleting interfaces}

It is possible to annotate build items with instructions to build
interfaces located in those directories and insert them in the start
of day typesystem. The command \url{add_interfaces} does so, taking a
item name and a list of interfaces to add. Similarly, interfaces may
be deleted; the command is called \url{del_interfaces} and takes the
same arguments.

For example, to move the interfaces Rd and Wr from item
\url{central_interfaces} to item \url{RdWr}:

\begin{verbatim}
del_interfaces('central_interfaces', ['Rd.if', 'Wr.if'])
add_interfaces('RdWr', ['Rd.if', 'Wr.if'])
\end{verbatim}

Note that the files \url{Rd.if} and \url{Wr.if} would also have to be
moved as well; this only changes the build system database used to
locate the interface files.

\subsection{Destroying build items}

The command \url{destroy} removes a build item from the database,
along with any build items that require it, transitive requirements
included. For example, the customizer executes the following commands
automatically for all intel trees, ahead of anything the user puts in
the choices file himself:

\begin{small}
\begin{verbatim}
set('ix86_arch', 1)
destroy('alpha_arch')
destroy('arm_arch')
destroy('mips_arch')

set('ix86_linux_plat', 1)
destroy('osf1_plat')
destroy('hpux_for_arm')
destroy('linux_for_arm')

set('intel_target', 1)
destroy('axp3000_target')
destroy('eb164_target')
destroy('eb64_target')
destroy('fpc3_target')
destroy('intel_smp_target')
destroy('maxine_target')
destroy('riscpc_target')
destroy('shark_target')
destroy('srcit_target')

set('pci', 1)
set('ns16550_serial_device', 1)
set('vga_text_mode', 1)
set('timer_rdtsc', 1)
set('fp_support', 1)
\end{verbatim}
\end{small}

The effect of this is that on the intel architecture, the resulting
build system doesn't even contain NTSCs for other architectures, for
instance.

\subsection{Causing files to be obtained from a different place using reloc}
The \url{reloc} command causes either an entire item or some files in
that item to be linked from a different location than they were
before. The first argument of the \url{reloc} command is an item name,
much like most of the other commands described here. If the second
argument is a string, it should be the path to the directory where the
source code for a build item can be found. For instance:

\begin{verbatim}
reloc('timidity','/homes/dr10009/hacked_up_timidity')
\end{verbatim}

would cause the \url{app/timidity} directory to be linked from
\url{/homes/dr10009/hacked_up_timidity} instead of (if the source
tree was set to the Cambridge live tree location)
\url{/usr/groups/pegasus/nemesis/live/master/app/timidity}.

In the second form, particular files may be moved. A Python dictionary
object mapping filenames in the item to new filenames should be given
as an argument.

\begin{small}
\begin{verbatim}
reloc('device_interfaces', {
        'Au.if':'@/interfaces/Au.if',
        'AuMod.if':'@/interfaces/AuMod.if',
        'AuPlaybackWriter.if':'/homes/dr10009/hack/interfaces/AuPlaybackWriter.if'
})
\end{verbatim}
\end{small}

Note that the `\texttt{@}' character is special; it is substituted for the path
name of the current choices file being read. Thus, the \url{Au} and \url{AuMod}
interfaces above specified relative to current \url{choices} file
instead of being given an absolute path.
In this form only, if the new filename is given as \url{None} (no
string quotes), then the file is removed from the build tree completely.

\subsection{Causing files to be obtained from a different place}

The \url{add_source_tree} command adds an additional source tree to
the build tree, after the current source tree.  Files found in the
new tree override the corresponding files in the original source tree. 

For example:

\begin{verbatim}
add_source_tree('/usr/groups/pegasus/users/dr10009/extra')
\end{verbatim}

adds a source tree that is searched for source code. Any code there
take precedence over the original source tree. 

It is possible to have multiple \url{add_source_tree} and \url{reloc}
commands in effect at once, in which case, for each build item, the
last \url{reloc} command is honoured.  If there are no \url{reloc}
commands for a build item, the source trees are checked in
reverse order to the way they were specified, and the first instance
of the build item found is used. 

To summarise, 
relocations take precedence over the tree search path, and later add
source tree commands take precedence over the earlier source tree commands.

\subsection{Modifying the blueprint directly}

There are a couple of back doors to customizing the blueprint
directly. The \url{add_item} command takes a build item constructed in
a similar syntax to the blueprint and adds it to the blueprint. It
must extended over only one line. The \url{tweak} command sets a field
in a particular item. These are intended to provide supplementary
functionality to the above commands.

The tweak command enables one of these fields to be added or, if it
was already present, replaced. For example:

\begin{verbatim}
tweak('CSIDCTransport', makefileflags, {'custom': 1})
\end{verbatim}

adds a \url{makefileflags} field to \url{CSIDCTransport}; the effect
is to prevent \url{CSIDCTransport}'s makefile from being
autogenerated. It is in an error if the second argument is not a valid
command name. The second argument may be quoted.


To use \url{add_item}, it is necessary to invoke one of the
item constructors of the file \url{glue/nemclasses.py}.
The fields and classes are described later, but first an example of
the use of \url{add_item}:

\begin{small}
\begin{verbatim}
add_item(AutoModule('Pcnfs',{
  description: 'Login service (Pcnfs based).',
  path: 'mod/security/pcnfs',
  makeflags: {'libsocket':1, 'libsunrpc':1},
  binobject: 'Pcnfs',
  system_interfaces : ['PcnfsLoginMod.if'],
  type : 'quad',
  value : 2}))
\end{verbatim}
\end{small}

This creates a new item called Pcnfs, describe as a PCnfs based login
service, residing at mod/security/pcnfs, linked against socket and
sunrpc libraries, producing a binary called Pcnfs and introducing a
system interface called \url{PcnfsLoginMod.if}. It is type quad, and
will be built but not placed in to the boot image by default. The item
is class AutoModule; all class constructors take the item name as the
first argument, and a dictionary of all the fields they define as the
second argument. 



\section{The Choices Editor GUI}

XXX; this code is out of date; it predates packages.

If you have python set up with the GTK widget set, you may edit
\url{choices} files using the Choices Editor. The choices editor reads
the blueprint database in much the same way as the build system, and
can execute choices files. Instead of building Nemesis, however, you
can view and change the Nemesis source database.

The choices editor has three levels of operation---beginner, expert and
deity mode. Deity mode is not fully developed yet, so will not be
described completely here until it is finished. The editor starts in
beginner mode. 

To start the editor, enter a source tree \url{glue} directory and
execute \url{choicesgui.py}, specifying a path to a \url{choices} file
as a command line option and specifying a path to a
\url{generic_blueprint.py} file that the \url{choices} file refers
to. For example:

\begin{verbatim}
cd $NP/glue
choicesgui.py $NP/choices.intel $NP/glue/generic_blueprint.py
\end{verbatim}

A window will appear containing a menu bar, a notepad style selector
attached to a list of items, and a large empty rectangle. Click on one
of the list items, and the large rectangle will be filled by a form
telling you about the item you selected. In beginner mode, you are
only shown some of the build items, and are only allowed to set the
status of build items. If you click on the drop down menu widget
labelled value, you can select a new value for the item you chose. The
\url{choices} file you gave as a command line argument will be
amended immediately to reflect the change you just made, and the user
interface will be updated to illustrate the change.

The build system will always use the latest \url{choices} file on
disk, so there is no need to quit the editor in order to build
things. The editor can be left running, and changes made in it will be
picked up as if the \url{choices} file had been edited directly with a
text editor.  Note that it is important to read the messages produced
on the terminal where the choices editor was run, because the choices
editor will not correct an already broken \url{choices} file nor can
it (yet) be guaranteed only to make legal changes.

You can use the notepad buttons to view different categories of build
items, and the (scrollable) list to select items within that
category. The list also shows you the resultant value of each option,
and what properties of each item have been overridden by your
\url{choices} file. You can use the File menu to select a different
\url{choices} file to edit.

In expert mode, you are shown all items that might be configurable,
rather than just the ones we have decided it is sensible for beginners
to configure. You will only be shown the text of the \url{choices}
file you are editing, and may modify it directly by hitting the
\url{edit} button. Then, you may edit the choices file and any changes
made through the method described above will be batched up in the
\url{choices} file until you hit either \url{commit} (to save the
changes) or \url{revert} (to discard the changes).

Deity mode adds the (so far unimplemented) ability to add new kinds of
item, shows you even options that may not be modified and allows all
fields in the blueprint database to be edited. The new \url{edit}
buttons on the item editor forms pop up dialogs that allow you to
specify a new value with reference to an old value.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Item classes}

\begin{description}
\item[BuildItem] The parent of all build item classes. Not to be used
directly.

\item[NTSC] Used to describe Nemesis Trusted Supervisor Code
routines. There should remain exactly one in the blueprint, otherwise
\url{glue/gennbf.py} will complain. These items must specify a path.

\item[Primal] Used to describe the primal routine. Again, only one per
image. Must specify path.

\item[Program] items describe pieces of code with one entry point that
are executed as separate domains. Programs may be placed in the boot
image, therefore they require path, qos and env fields.

\item[PosixProgram] items are like programs (PosixProgram is a subtype
of Program), but in addition arrange for posix compatibility libraries
to be linked against the program. At the time of writing, this means
that PosixPrograms may have an ANSI C \url{main()} function. They
require path, qos and env fields (because they inherit from Programs).

\item[Module] items describe Nemesis stateless modules. They require
path and exports fields.

\item[AutoModule] items describe Nemesis stateless modules, but they
do not require an exports field because it is assumed that AutoModules
export into the primal (i.e., main) namespace a symbol with the same name
as the AutoModule item itself.  They still require a path, however.

\item[Document] items describe directories that build
documentation. They require a path.

\item[PureConfiguration] items exist only to provide a configuration
option; they must not have a path.

\item[InterfaceCollection] items are directories containing
exclusively interfaces. Interfaces may be present in other items as
well, but this item type is used for items that contain only
interfaces. Require path.

\item[StaticLibrary] items produce static libraries, and require path
to be specified.

\item[BlobDirectory] items contribute ``Blobs'' of data to the boot
image. They require path and bloblist options.

\end{description}

\section{Item fields}

\begin{description}

\item[associated cpp name] fields are optional. If present,
\url{glue/plumbtree.py} will generate header files and entries in
\url{mk/autoconf.mk} describing the state of the build item. (Note
that the field name is \url{associated_cpp_name}).

For example, the field:

\begin{verbatim}
  associated_cpp_name : 'REGION',
\end{verbatim}

would, if the item had type bool, arrange for \url{CONFIG_REGION} to
be set to zero or one. Setting to zero results in:

\begin{verbatim}
#undef CONFIG_REGION

#CONFIG_REGION is undefined
\end{verbatim}

in \url{h/autoconf/region.h} and \url{mk/autoconf.mk}
respectively. Setting to one results in:

\begin{verbatim}
#define CONFIG_REGION 1

CONFIG_REGION=y
\end{verbatim}

If the item had type quad, for values 0, 1, 2 and 3 respectively,
\url{glue/plumbtree.py} would generate, for value set to 0:

\begin{small}
\begin{verbatim}
#define CONFIG_REGION_VALUE 0
#undef CONFIG_REGION
#undef CONFIG_REGION_SUPPORT
#undef CONFIG_REGION_BUILD
#undef CONFIG_REGION_NBF

#CONFIG_REGION_NBF is undefined
#CONFIG_REGION is undefined
#CONFIG_REGION_SUPPORT is undefined
#CONFIG_REGION_BUILD is undefined
\end{verbatim}
\end{small}

For value set to 1:
\begin{small}
\begin{verbatim}
#define CONFIG_REGION_VALUE 1
#define CONFIG_REGION 1
#define CONFIG_REGION_SUPPORT 1
#undef CONFIG_REGION_BUILD
#undef CONFIG_REGION_NBF

CONFIG_REGION = y
CONFIG_REGION_SUPPORT = y
#CONFIG_REGION_BUILD is undefined
#CONFIG_REGION_NBF is undefined
\end{verbatim}
\end{small}

For value set to 2:
\begin{small}
\begin{verbatim}
#define CONFIG_REGION_VALUE 2
#define CONFIG_REGION 1
#define CONFIG_REGION_SUPPORT 1
#define CONFIG_REGION_BUILD 1
#undef CONFIG_REGION_NBF

CONFIG_REGION = y
CONFIG_REGION_SUPPORT = y
CONFIG_REGION_BUILD = y 
#CONFIG_REGION_NBF is undefined
\end{verbatim}
\end{small}

For value set to 3:
\begin{small}
\begin{verbatim}
#define CONFIG_REGION_VALUE 3
#define CONFIG_REGION 1
#define CONFIG_REGION_SUPPORT 1
#define CONFIG_REGION_BUILD 1
#define CONFIG_REGION_NBF

CONFIG_REGION = y
CONFIG_REGION_SUPPORT = y
CONFIG_REGION_BUILD = y
CONFIG_REGION_NBF = y
\end{verbatim}
\end{small}

For a multiple choice option, a CPP macro postfixed with \url{_VALUE}
is defined with the index of the choice selected. Then, each choice's
symbolic name is treated the same as boolean set to false or true. For
example, for \url{memsys} if set to \url{EXPT}:
\begin{small}
\begin{verbatim}
#define CONFIG_MEMSYS_VALUE 1
#undef CONFIG_MEMSYS_STD
#define CONFIG_MEMSYS_EXPT 1

#CONFIG_MEMSYS_STD is undefined
CONFIG_MEMSYS_EXPT = y
\end{verbatim}
\end{small}

or if set to \url{STD}:
\begin{small}
\begin{verbatim}
#define CONFIG_MEMSYS_VALUE 0
#define CONFIG_MEMSYS_STD 1
#undef CONFIG_MEMSYS_EXPT

CONFIG_MEMSYS_STD = y
#CONFIG_MEMSYS_EXPT is undefined
\end{verbatim}
\end{small}

Refer to the source code of \url{glue/plumbtree.py} to see how this is
implemented.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[binobject] fields override module, programs, automodules, ntsc
and primal build items, specifying a binary object name that the item
produces. By default, the item name is used as the binary object name. For example:

\begin{verbatim}
  binobject : 'Lance',
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[bloblist] is a field for BlobDirectory items only. They are
  lists of (blob 
filename in directory, handle in NBF name, namespace anme)
3-tuples. For exmaple:

\begin{verbatim}
bloblist : [('boot.rc', 'blobrc', 'blobrc'), ('init.rc', 'initrc', 'initrc')]
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[description] fields are strings describing the item. They are
optional for any item class. For example:

\begin{verbatim}
description : 'common (ethernet, IP, UDP) protocol code',
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[doctext] fields are strings documenting the contents of thing
the item refers to. They are optional for any item class. For example:

\begin{verbatim}
doctext : 'The windowing system server handles window allocation,
 clipping and event demuxing. It also interfaces with a window manager.',
\end{verbatim}

Note that this should be a single line.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[env] fields are compulsory for programs and posix programs. They
are dictionaries, and must define a number of contexts with key
`contexts', keys `defstack', `heap' and `sysheap' as strings suitable
for \url{nembuild}, a number of frames with key `frames', a boolean
called `kernel' set to 1 if the program is to be given kernel
privileges, and optionally a key `autostart' set to 1 if the program
is to be automatically started at boot time.

\begin{verbatim}
env : {'autostart':1,'contexts':32,'defstack':'8k','endpoints':128,
'frames':64,'heap':'128k','kernel':1,'sysheap':'32k',},
\end{verbatim}

Note that this should be a single line.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[helptext] fields are strings specifying what the effect of
configuring an option might be. They are optional for any item
class. For example:

\begin{verbatim}
helptext : 'Enable this to cause a backdrop to be displayed in the
windowing system',
\end{verbatim}

Note that this should be a single line.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[growrecursive] fields are booleans, intended to be set for
directory items. They cause the build system to not grow directories
recursively. Usually, the whole contents of the source tree at the
path specifed and below is linked or copied in to the build tree.

For example, the \dir{h} directory build item specifies:

\begin{verbatim}
  growrecursive : 0,
\end{verbatim}

otherwise the entire contents of al \dir{h} subdirectories would always be
present in all build trees, including including those specific to
architectures other than the one being built.
%\marginpar{This makes no sense, h or app?}
% so it was a mistake: corrected to \dir{h}, rf 1998/05/18

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[makefileflags] fields are instructions to the makefile
generator. They are dictionaries, which may define any of the
following:

\begin{description}

\item[custom] set to 1 to prevent the makefile from being
autogenerated.

\item[libio] set to 1 to link libraries defining IO functions with the
build item.

\item[install] set to a list of filenames of files stored in the
directory of the build items. 

\item[localrules] set to 1 to cause \url{local.rules.mk} to be
included in make for that makefile.

\item[libws] set to 1 to request the static window system rendering
library to be linked.

\item[libsocket] set to 1 to request BSD sockets code to be linked.

\item[donotinstall] set to 1 to prevent the binary produced from being
installed when \cmd{gnumake installmost} is invoked.

\item[libsunrpc] set to 1 to cause the SUN RPC static library to be
linked with the binary.

\item[libmesa] set to 1 to cause the MESA rendering static library to
be linked with the binary.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[path] fields are compulsory for most build item classes. They
are paths relative to the root of the build tree, indicating where the
build item is located. For instance:

\begin{verbatim}
  path : 'mod/nemesis/csidc',
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[requires] fields are lists of items that must be \emph{active}
for the item with the requires field to be active. 

For example, the WTime automodule item has a requires line at the
  moment of:
\begin{verbatim}
  requires : ['RTC', 'ix86_arch']
\end{verbatim}

This means that it will be disabled if \url{ix86_arch} or \url{RTC}
are disabled. Disabled is defined as set to 0/No for bools and
quads, or for multiple choice type items to a choice where the first
option is set to 0. If one of the required items of an item is
destroyed, that item is destroyed as well.

There is a special form for requesting one particular choice out of a
multiple choice item. This is presently used to depend on one
particular memory system. For examples:

\begin{verbatim}
requires : [('memsys', 0), 'ix86_arch']

requires : [('memsys', 1), 'eb164_target']
\end{verbatim}

The first example requires memory system 0, the first choice in the
memory system (i.e., memory system standard). It also requires ix86
architecture. Similarly, the second example requires the second choice
memory system `experimental', and an eb164 tree.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item[section] fields are compulsory fields used to divides items in
to sections. The sections are purely for readability of the blueprint
and use of a GUI. The section ``unclassified'' exists as a
catchall. For example:

\begin{verbatim}
section : 'WS'
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item[system\_interfaces] is optional for all items  with paths except
InterfaceCollections where it is compulsory. It is a list of strings
that are filenames of interfaces, in the directory specified by the
path of the item. For example:

\begin{verbatim}
  system_interfaces : ['CSIDCTransport.if', 'CSClientStubMod.if'],
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[type] fields specify the configuration type of the build
item. There are three different kinds; boolean (`bool'), quad
(`quad') and multiple-choice types. Examples of each are:

\begin{verbatim}
type : 'bool'

type : 'quad'

type : [(1, 'standard', 'STD'), (1, 'experimental', 'EXPT')]
\end{verbatim}

Booleans are yes/no choices (surprisingly), generally used for
configuration data. For instance, all the architecture, target and
platform PureConfiguration build items have type boolean. 

Quads are used for compiled pieces of code, indicating whether
nothing should be done for that code, that code should be supported,
that code should be built or that code should be placed in to the
bootable image. An item of type quad is regarded as active if it is set
to anything apart from off.

Multiple choices are specified by a list of (activity flag, friendly
name, symbolic name) 3-tuples. An item with a multiple choice type may
be set to exactly one of these choices at once. The item is active if the
chosen value's activity flag is set to 1. The friendly name is for the use of
graphical front end, and the symbolic name is for use as an alias to
an index into the list for the choices file.

All items have a type.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[value] fields specify the current status of the build item. In
\url{glue/generic_blueprint.py}, this is the default value for the
option. The customizer modifies these fields according to the current
target and the \url{choices} file. All items have a value field.

If the type field is `bool', the value is 0 or 1.

If the type field is `quad', the value is 0, 1, 2 or 3.

If the type field is a multiple choice, the value is an index starting
at 0 in to that list.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item[qos] fields are for Program and PosixProgram items.  For example:

\begin{verbatim}
  qos : {'extra':1,'latency':'20ms','period':'20ms','slice':'0ns',},
\end{verbatim}

The are dictionaries that must define the keys 'extra' (as one for
extra time for that program or zero for no extra time), 'latency',
'period' and 'slice' as time parameters. The time strings are passed
straight to \url{nembuild}; see the documentation for that command for
their meanings.
\end{description}

At this point, the careful reader should have information to understand
the file \url{glue/generic_blueprint.py} with. That file is a useful
source of examples. \url{glue/generic_blueprint.py} is written in
python, and can be automatically generated by
\url{glue/regenerate_blueprint.py}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Choices language reference}

Lines containing entirely whitespace are ignored.

Any characters in between a \verb'#' and a newline are ignored, including
the \verb'#'.

The character \verb'@' is replaced with the path name of the current
choices file.

All other lines are Python method invocations, from the following:

\begin{verbatim}

set(itemname, value)
add_program(fullname)
add_module(fullname)
add_interfaces(itemname, interfacelist)
del_interfaces(itemname, interfacelist)
tweak(itemname, fieldname, value)
add_item(item)
destory(itemname)
reloc(itemname, override)
add_source_tree(pathname)
\end{verbatim}

where:

\begin{description}
\item[itemname] is the name of a build item in single quotes.

\item[fullname] is the path of a binary from the root of the build
tree, in single quotes.

\item[interfacelist] is a list in squares brackets of interface names,
in single quotes.

\item[fieldname] is the name of a field, optionally in single quotes.

\item[item] is a constructed item object, built using the constructors
defined in \url{glue/nemclasses.py}

\item[override] is either a string or a dictionary mapping filenames
to filenames.

\item[pathname] is a full path to a directory.
\end{description}

Each line must be self contained; the above method invocations must
not span multiple lines.



\section{layfoundations and changefoundations}

\url{layfoundations} is used to first create a tree. It is recommended
that you keep environment variables, called NM and NP around,
with paths to your master and build trees around.
The build system does not use them, however, but various small
scripts people tend to write may. If you have a local copy of the
master tree, your build will be quicker if you use it and you will
save  load on the network. (In Cambridge, local copies of the master
tree are stored in some machines in \url{/usr/opt/nemesis/live}).

If you have defined them, then:

\begin{verbatim}
cd $NM/glue
./layfoundations.py $NB $NM intel ~/choices.intel
\end{verbatim}%$

\noindent may be a sensible way to set up your build tree. This
specifies a tree 
targeted to build images for Intel machines, with a choices file
residing in the root of your home directory called
\url{choices.intel}. 
If it is omitted, then no symlink will be created. If the file
specified does not exist, then the symlink will be created anyway and
the build system will create a null file there (using touch).  To
build direct from the master tree, use the location of the master tree
instead.

Some targets have more than one build platform. To override the
selection in such cases, try something like:

\begin{verbatim}
cd $NP/glue
./layfoundations.py -platform=linux_for_arm $NB $NP shark $NP/choices.intel
\end{verbatim}

Note that options may start either with either a minus or plus, but
some python interpreters have been miscompiled and will only accept a
plus.

The script \script{glue/changefoundations.py} is in fact a symbolic
link to \script{glue/layfoundations.py} that exists in build trees.
\script{glue/changefoundations.py} is specifically executed by
\cmd{gnumake itso} in the root of a build tree, to tidy up a tree as necessary.

Historical note: the tool \url{mkbuildtree} is an \emph{unsupported}
wrapper around \url{glue/layfoundations.py}, which is less flexible
and often out of date. 

\section{Creating a new set of blueprint files}

The tool \url{glue/regenerate_package.py} can be used to generate a
replacement set of glue/packages files, which it saves in a directory
called \url{new_packages} in the current directory.  The idea is that
contributors to a Nemesis tree develop their changes using a
\url{choices} file, then run \url{regenerate_packages} to generate a
new generic blueprint. This new generic blueprint can then be checked
in to replace the old generic blueprint in the Nemesis distribution.

Note that \url{regenerate_package} does not perform the sanity check
that is usually done by the customizer, as it would disable all the
architecture-specific items.  Therefore, people using
\url{regenerate_package} should be careful that they specify a
\url{choices} file that gives sensible defaults, as these will become
the defaults for all users of the new generic blueprint.

It is of course also possible to write and edit the package files
manually. regenerate packages is intended to ease major changes such
as splitting packages.

\section{Constructing expansion packages}

We have two kinds of packages; the ones that make up the
source tree and expansion packages. This section introduces expansion
packages, which don't involve the source code management scheme at
all. The release notes describe how to construct the other kind of
package, which will go through the source code management scheme.

Expansion packages are nothing more than sparse trees with extra
choices language code to configure the build system in.  As mentioned
above, a package consists of a specially written choices file, and a
collection of code. The choices file should use the `\texttt{@}'
feature of the choices language to avoid using absolute path
names. Here is an example package choices file, to serve as an
extended example of a choices file and a prototypical package.

\begin{small}
\begin{verbatim}
# Dickon's experimental audio package, v0.1, against the live tree

add_interfaces(
  'device_interfaces', # so is this
  ['Au.if', 'AuMod.if', 'AuPlaybackWriter.if']
)
reloc('device_interfaces', {
        'Au.if':'@/interfaces/Au.if',
        'AuMod.if':'@/interfaces/AuMod.if',
        'AuPlaybackWriter.if':'@/interfaces/AuPlaybackWriter.if'
})

add_module('mod/au/aumod')
set('aumod', 2)
reloc('aumod', '@/aumod')
tweak('aumod','section','Audio')

add_program('dev/isa/lksound/lksound')
tweak('lksound', 'makefileflags', {'custom':1})
reloc('lksound', '@/lksound')
tweak('lksound','section','Audio')

add_program('app/amp/amp')
tweak('amp', 'makefileflags', {'custom':1}) 
reloc('amp', '@/amp')

add_program('app/auview/auview')
reloc('auview', '@/auview')

add_program('app/tone/tone')
tweak('tone', 'makefileflags', {'libio':1})
reloc('tone', '@/tone')

add_program('app/timidity/timidity')
tweak('timidity', 'makefileflags', {'custom':1})
reloc('timidity', '@/timidity')

add_program('app/doom/ndoom')
tweak('ndoom', 'makefileflags', {'custom':1})
reloc('ndoom', '@/doom')

add_program('app/udpaudio/udpaudio')
reloc('udpaudio', '@/udpaudio')

tweak('amp','section','Audio')
tweak('aumod','section','Audio')
tweak('auview','section','Audio')
tweak('tone','section','Audio')
tweak('ndoom','section','Applications')
tweak('timidity','section','Applications')
tweak('udpaudio','section','Applications')

# Intel NTSC Memory management hack
reloc('ntsc_ix86', {'intel/mmgmt.c' : '@/mmgmt.c'})
\end{verbatim}
\end{small}

\section{Internals}

Beginners can skip the rest of this manual. 


\begin{figure}
\center\epsfig{file=buildtogether.eps}
\caption{Structure of the build system}
\label{fig:nem}
\end{figure}



\url{changefoundations} is used to cause bits of the procedure
executed by \url{layfoundations} to be repeated. The procedure is
divided in to a number of steps, each one with a symbolic name:

\begin{description}
\item[locatetree] takes the name of the
build tree as an argument. This is the first step, which is why the
build tree location goes first in the above examples.
\item[createtree] creates the tree directory and a minimum skeleton of
directories inside it. It is not destructive.
\item[gentreeinfo] creates the file \url{glue/treeinfo.py} that stores
the location of the build tree, source tree, target and so forth. It
also creates the choices symlink. gentreeinfo takes two or three
arguments, which are the name of the source tree, the target name and
optionally the path to
choices. The \url{-copy} options causes the tree to be set up to copy
files rather than link them, and is considered when gentreeinfo
happens. The \url{-platform} option mentioned above is similarly
considered at this point.
\item[geninfra] generates all the autogenerated makefiles. (Invoked by
\cmd{gnumake grow}).
\item[filldirs] fills all the directories out with symlinks. (Invoked
by \cmd{make grow}).
\item[genmake] creates a few important symlinks that aren't created any
other place; the symlinks from platform and target makefiles to
\url{platform.mk} and \url{target.mk}, the symlink from layfoundations
to changefoundations and the root makefile. It also creates
\url{mk/source.mk}.
\end{description}

Example:

\begin{verbatim}
cd $NB/glue
./changefoundations.py -geninfra
\end{verbatim}%$

recreates all the infrastructure makefiles. 

\section{Under the hood}

Only read this section if you need to modify the internals of the
build system.

Firstly, it is worth pointing out that there may be some residue from
the TCL based configuration scheme. Please point any out to the author
if you notice anything. 

Secondly, below is a description of the function of each file in the
glue directory, to remove some of the mysticism surrounding that
directory.

\begin{description}
\item[blueprint.py] is a python module that is imported by any python
code that wishes to access the build system database. It uses
\url{generic blueprint.py} as the basis of the database, but invokes
\url{customizer.py} in order to specialize it using the
\url{treeinfo.py} target, platform and architecture, some knowledge in
the customizer and the contents of the choices file.

\item[buildutils.py] is a python module defining a few useful
functions; for instance, most symlinks are created using the symlink
routine in here rather than the Pyhton OS module. There should be
nothing Nemesis specific in here.

\item[configutils.py] contains a routine to figure out the active
subset of the build tree. (Previously it contained a lot more, but now
it barely justifies remaining a separate file).

\item[customizer.py] defines the class that provides, as methods, all
the commands used in \url{choices}. An object of class Customizer is
created, and \url{choices} commands are really just invocations on
that object. \url{customizer.py} includes some knowledge of what the
different targets mean.

\item[depsshow.py] is a stand alone python program that reads all
dependency file and calculates the inverse mapping. It is invoked by
the \url{uses.txt} rule of the root Makefile.

\item[gendetails.py] generates a string used to put identification in
to autogenerated files.

\item[gendirs.py] creates the directories comprising a build tree.

\item[generic blueprint.py] contains generic data about the nemesis
tree. \url{blueprint.py} specialises this for particular build
tree. In \url{generic_blueprint.py}, all targets are off by default;
the Customizer will turn them on for particular machines.

\item[geninfrastructure.py] figures out the set of makefiles to
generate.

\item[geninstalllinks.py] is a standalone program invoked by the
\url{links} directory makefile to create all the installation links.

\item[genmakefile.py] is used by \url{geninfrastructure.py} to
actually generate makefiles.

\item[gennbf.py] generates input for \url{nembuild}; it is invoked by
the \url{boot/images} subdirectory makefiles.

\item[growtree.py] is the entry point for \cmd{make grow}, invoking geninfra
and filldirs as necessary.

\item[layfoundations.py] is describe above. It is a standalone program.

\item[nemclasses.py] contains the class definitions for all build
items.

\item[plumbtree.py] is invoked whenever the choices file changed, as a
standalone program, in order to create the autoconf header files and
makefile.

\item[qosutil.py] converts CPU time fractions to QoS parameters
suitable for gennbf.

\item[sourcemanager.py] manages obtain source code, using the data in
treeinfo.

\item[treeinfo.py] is autogenerated by layfoundations to store some
data about the build tree.

\end{description}

\end{document}

