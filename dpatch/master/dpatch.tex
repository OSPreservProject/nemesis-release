\documentclass{article}
\usepackage{a4wide}
\title{The \texttt{dpatch} source code management system \\ Users Guide}
\author{Dickon Reed}
\date{9th December 1998}
\begin{document}
\maketitle
\tableofcontents
\section{Overview}



\texttt{dpatch} is an automated source code management system. It was
originally designed for controlling Nemesis source code, but contains
no Nemesis specific features. \texttt{dpatch} uses a new patch file
format and contains two new tools:

\begin{description}
\item[ddiff] generates patches. It it is a wrapper around \texttt{diff}.

\item[dpatch] performs various operations involving patches and source
repositories. The main ones are:
\begin{itemize}
\item Creation of a \emph{patch repository}.
\item Creation of a \emph{package} inside a \emph{patch repository},
with an initial \emph{branch}.
\item Adding a new patch to a branch.
\item Forking a branch to create a new branch.
\item Test application of a patch to a directory.
\end{itemize}
\end{description}

\texttt{dpatch} is implemented in Python and makes use of the standard
tools \texttt{diff}, \texttt{patch} and the revision control systems PRCS and
RCS. However, in the future other versions of \texttt{dpatch} may be
written to allow other revision control systems to be
used. \texttt{dpatch} manages this by storing projects as a collection
of patches and maintaining a read only PRCS repository for the
convenience of developers. Potentially, multiple repositories
maintained by different tools could be automatically maintained in parallel.

\texttt{dpatch} provides a layer on top of existing tools which allow
patches to be generated by untrusted code developers and supplied to
\emph{Tsars} for review. The Tsars may then accept the patch, in which
cases it is added to a branch of one of the packages in a project, or
the Tsars may reject a patch or request the patch author clean up the
patch somehow. To aid the Tsars, project specific tools can be made
to automatically verify that a patch applies cleanly and results in a
project that builds and works properly. An example of such a tool,
called \texttt{nemtester.py} is included. The emphasis in
\texttt{dpatch} is to make the life of the Tsars as easy as possible,
so that Tsars may manage code changes to large projects.

\texttt{dpatch} uses a new patch format that includes fields that
document the patch changes. Central project documentation is
automatically updated, so developers can tell at a glance the current
version and history of a package. Finally, \texttt{dpatch} is designed
to scale to large projects where many sites may maintain particular
packages that make up one large project. Potentially, each branch of
each package may have a different set of Tsars.

The canonical form of a \texttt{dpatch} project is a set of files and
directories called a patch repository. Such a repository consists of:

\begin{itemize}
\item One top level directory per package, named after that package.

\item One directory per branch, within each package directory, named
after that branch. Branches have symbolic names such as \texttt{live} or
\texttt{stable2}.

\item One file per applied patch, containing the patch, named with
consecutive integers. 

\item In all but the first branch of each project, a file called
\texttt{from} describing where the branch is attached to an earlier branch.

\item A file called \texttt{metaupdates} that documents the history of
the patch tree.
\end{itemize}

The current version of \texttt{patch} also maintains a PRCS repository
containing one PRCS project per package, with the same branch
structure. This may be rebuilt, however, by \texttt{dcheckin}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Tutorial: Working with an existing project}

Read this section to learn how to work with an existing
\texttt{dpatch} project. As a non-Tsar developer, you have read only
access to a PRCS repository and possibly some ready checked out
copies of the latest versions of the projects, containing the project code you are
working on. Therefore, most of what is described in the PRCS tutorial
is appropriate to you. You may not, as a non-Tsar, check in to this
repository directly, however; you must send a patch file to a Tsar who
will review your changes.

You should set the environment variable \texttt{PRCS\_REPOSITORY} to
the location of your shared project repository. For example, Cambridge
Nemesis developers would set this to:

\begin{verbatim}
/usr/groups/pegasus/nememis/PRCS
\end{verbatim}

Then, you should create a
new directory for a working copy of each package, and execute a PRCS
checkout command for each package you wish to use. If, for example,
you are using a package called \texttt{ccore} with a branch called \texttt{live}, you
should execute something like:

\begin{verbatim}
mkdir source
cd source
prcs checkout -r live.@ ccore
\end{verbatim}

You may then edit the contents of this directory \footnote{Nemesis
developers should create and edit a sparse source tree on backed up
space and keep their checked out source tree on scratch disc, however,
to save backed up storage. An rdisted copy of the latest stable
versions of all packages may also be available}.

Later, you may wish to contribute your changes back to the project. To
do this, you must create a \texttt{dpatch} file. To do so, use the
\texttt{ddiff.py} tool or write the patch manually. The easiest way to
use \texttt{ddiff.py} is to use \texttt{ddiff.py prcsdiff} mode. You
will need to go back to the root of your checked out working tree and
execute something like:

\begin{verbatim}
ddiff.py prcsdiff > ~/mypatch1
\end{verbatim}

You will be interactively shown each diff you have made and asked to
describe it, then asked for an overview, your name and email
address. You should now check the patch file created; you can edit it
if you wish to correct your documentation or remove certain changes. 
Now, you should present your patch to the project Tsars in the manner
the Tsars have requested for your project.

Above we used the \texttt{prcsdiff} mode of \texttt{ddiff.py}. This is
designed for users who have worked on PRCS checked out versions of
packages. \texttt{ddiff.py} supports other ways of working. 

\begin{description}
\item[create] mode assumes that all the files in the current working
directory are new and generates a single patch that creates all the
files. This is useful for checking in the first version of a project,
and is usually used by Tsars to create projects.

\item[privlink] is for users who have used a command such as
\texttt{lndir} to create a tree of symlinks to their checked out code,
and have modified the project by breaking symlinks and replacing them
with copies of the files which they then modify. This is a useful way
of working when projects are large enough that you do not wish to
backup entire working copies. \texttt{ddiff.py} will just diff real
files, ignoring symlinks. In this mode, you need to specify a path to
the unmodified version of the tree as the last argument; the symlink
tree should be rooted in the directory where \texttt{ddiff.py is invoked}.

\item[privcopy] is for users who have both an unmodified complete copy
of a tree and a modified complete copy and wish to generate diffs
between their modified version and the unmodified version. Like
\texttt{privlink} mode, you run \texttt{dddiff.py} in your current
working directory and specify a path to the unmodified tree as an
extra argument.

\item[deltas] is like \texttt{privcopy}, but only examines files
present in both the modified and unmodified trees. \texttt{privcopy}
will generate a patch that creates all the new files in the modified
tree, but \texttt{deltas} generated patches will not create new files.

\item[sparse] is like \texttt{privcopy}, but if files are missing from
the modified tree, then the generated patch will not try to delete
them. This is useful for projects with build systems that support
sparse trees; the idea is that the build system overlays sparse trees
on top of the distribution tree using symlinks. 
\end{description}

You will probably find \texttt{prcs merge} useful; it allows you to
update your source tree interactively to reflect upstream project
changes. See the PRCS documentation.

\section{Tutorial: Creating a new project tree}

First of all, place a file called \texttt{.dcheckinrc} in your home
directory. This tells \texttt{dcheckin.py} where to find the
repositories. I have as my \texttt{.dcheckinrc}:

\begin{verbatim}
{
    'project description': 'Nemesis',
    'patch tree' : '/usr/groups/pegasus/nemesis/patches',
    'prcs repository': '/usr/groups/pegasus/nemesis/PRCS',
}
\end{verbatim}

You should arrange for at least your patch tree directory to be backed
up regularly. 

Make sure the patch tree and prcs repository directories do not
exist. You can now execute, from any directory:

\begin{verbatim}
dcheckin.py init
\end{verbatim}

This will create the patch tree and PRCS repository directories as
described in your \texttt{.dcheckinrc} file.

Now, you have an empty patch tree, so you need to create a package and
initial branch. I first created a package called \texttt{ccore}, and a
branch called \texttt{live}. I intend to use this for development of
the package, and will at a later point fork it to create a stable
branch for users to work with. I type:

\begin{verbatim}
dcheckin.py create ccore live
\end{verbatim}

This will create for you all the directories and files necessary for
\texttt{dcheckin.py} to work. You will be prompted for the title of your tree;
the string you enter is just used at the start of the \texttt{updates}
log file. \texttt{dcheckin.py} may be made non interactive by adding
tree and branch titles to your \texttt{.dcheckinrc}.

Now you are ready to create patches. You may write patches by hand or,
more typically, use \texttt{ddiff.py} to create a patch. Let us assume
you have an existing directory full of source code to incorporate in
to the project. Supposing that directory is called
\texttt{/usr/groups/pegasus/nemesis/release}, you would execute:

\begin{verbatim}
cd /usr/group/pegasus/nemesis/release
ddiff.py create > ~/patch1
\end{verbatim}

You should now edit \texttt{patch1} and add lines like this to the
start of the file, in order to document your change:

\begin{verbatim}
author_email('dr10009@cam.ac.uk')
author_name('Dickon Reed')
overview('Create the Nemesis Release from existing source')
\end{verbatim}

You should also replace all the strings ``describe me'' in the patch
with descriptions of the files and directories created. 

You can now read this patch file in your home directory, augment it
with descriptions of your changes, and check it into your new patch
tree by executing:

\begin{verbatim}
dcheckin.py commit ccore live ~/patch1
\end{verbatim}

You and your users should arrange to set the environment variable
\texttt{PRCS\_REPOSITORY} to point to the location of the PRCS
repository you have created as defined by your \texttt{.dcheckinrc}
directory. Then you can create a working copy of the project in the
current directory by executing:

\begin{verbatim}
prcs checkout -r live.@ ccore
\end{verbatim}

As new patches become available, you should check them through and
then apply them. Nemesis uses a script called \texttt{nemtester.py} to
check a patch by checking out a working copy of the project from the
PRCS repository, applying a patch to the working copy and checking
that the resulting tree still builds and executes. It may be invoked,
for instance, with:

\begin{verbatim}
nemtester.py live ~/patch2
\end{verbatim}

Once you have approved a patch, you may commit it to the patch tree
with:

\begin{verbatim}
dcheckin.py commit ccore live ~/patch2
\end{verbatim}

The file \texttt{metaupdates} is used for locking and documenting
changes to the project tree; it is automatically created and updated
by \texttt{dcheckin.py}. It is under RCS control.

Every now and then, you may wish to fork a branch of a project, for
instance to allow parallel work on a stable version and a development
version, or to allow an experimental development branch. Suppose I
wish to fork \texttt{ccore}'s live branch as created above to form a stable
branch, I would execute:

\begin{verbatim}
dcheckin.py fork ccore live stable1
\end{verbatim}

If you wish to make the patch archive visible to the world, you may
use \texttt{dcheckin.py} to generate a web page indexing your
archive, with:

\begin{verbatim}
dcheckin.py publish /your/web/documents/index.html
\end{verbatim}

Then, make your archive available under
\texttt{/your/web/documents/patches} and it will be accessible from
the web page. \texttt{dcheckin.py} is able to
download such a page on a web server and build a local copy of a the
patch repository and PRCS repository, as if the code had been run
locally, using the webimport command. For example, if the HTML created
above was available as
\texttt{http://www.foobar.org/our/project/patches/index.html}, a
remote user could write a \texttt{.dcheckinrc} containing paths to a
new patch tree and a PRCS repository and execute:

\begin{verbatim}
dcheckin.py webimport http://www.foobar.org/our/project/patches/index.html
\end{verbatim}

That user could then arrange for this command to be run daily, for
instance. Patches will only be downloaded from the upstream site once.

\section{\texttt{dpatch} file format specification}

A patch file describes the changes between two different source
trees. This section describes one particular patch file format, known
as \texttt{dpatch}. \texttt{dpatch} files may be autogenerated or may
be written by hand. \texttt{dpatch} files are designed to be easily
parsable from python, though the fact that a python interpreter will
often be reading a \texttt{dpatch} file is not to be taken as a license to use
python language features that are not described in this document.

A \texttt{dpatch} consists of a number of commands. Some commands
declare information about the patch- the author of the patch, for example. Other commands create, modify or move files in the
destination source tree. The order of the action commands is
important, but the order of information declaration commands is not
important. By convention, though, all information declarations should
be made at the top of a file so that the file can be easily inspected.

\subsection{Basic Syntax}

A hash character in the first column of a line introduces a
comment. 

An identifier followed by a parenthesised list of arguments is a
command. Whitespace is insignificant inside the paranthesised list;
newlines are only allowed at the end of commands or inside the
parenthesised list. Optional arguments may be omitted, included in the
order specified, or included using name binding of the form parameter
name, followed by an equals sign, followed by value.

Identifiers are sequences of alphanumerics and underscore, but they
must not start with numerics.

Most command arguments are strings; strings may be expressed in
several ways. Strings may be concatenated by use of a plus operator. A
string consists of either a single quote, a double quote or three
double quotes, the string itself and another instance of the same kind
of quoting used to open the file. Strings may be prefixed with a lower
case \texttt{r} to turn off all escaping, otherwise normal C style escaping is
performed. Only the triple double quote string may extend over multiple
lines.

Booleans are either 0 for false or 1 for true.

Non-printable characters should be encapsualted using Base 64 as described in RFC
1421 (``Privacy Enhancement for Internet Electronic Mail: Part I:
Message Encryption and Authentication Procedures'', section 4.3.2.4,
``Step 4: Printable Encoding''). The special function:

\begin{verbatim}
base64decode(base64_encoded_string)
\end{verbatim}

should be used in place of a
string to represent such a binary. The special function:
\begin{verbatim}
chr(ascii_value_as_integer)
\end{verbatim}
is equivalent to the single character of
the same ASCII value string.

In the following comamnd descriptions, parameters are given as parameter
name:type. Curly braces are used to indicate optional arguments. 



\subsection{Information declaration commands}

Some information declaration commands are compulsory, as marked in
their descriptions below. 

\begin{description}

\item[filename(filename:string)] declares the working filename for the
patch file. This filename is a hint to whatever systems archive
\texttt{dpatch} files prior to them being committed in to a
tree. Optional. Filenames should consist of a alphanumerics and
underscores only. There is no length limit, but short filename
descriptions are encouraged. I suggest a patch filename convention of,
in sequence:

\begin{itemize}
\item The intials of the author of the patch.
\item The date, in the format YYYYMMDD.
\item An ascending lower case letter. a for the first patch of the
 day, b for the second etc.
\item An underscore
\item A very brief description of the patch, using lower case words
 separated by underscore.
\end{itemize}

\item[author\_email(emailaddress:string)] declares the email address of the author
of the patch file. Compulsory.

\item[author\_name(name:string)] declares the friendly name of the author of
the patch file. Optional.

\item[generator(generating\_program:string)] declares the name and version of the program
used to generate the file. The value ``byhand'' means that
the \texttt{patch} file was generated by hand. Optional.

\item[overview(des:string)] gives an overview of the contents and
authorship of the patch. Compulsory.

\item[nature(keyword:string)] gives a hint about the effect of the
patch. Optional. 

Suggested natures are:

\begin{description}
\item [fix] A small, non controversial bug fix.
\item [doc] A documentation enhancement.
\item [comment] Extra comments only.
\item [rewrite] A rewrite of some functionality.
\item [tidy] A code tidy.
\item [new] New code or features.
\item [pervasive] A significant, project wide affecting change.
\item [complicated] The default, if the field is omitted. Means that
the change is a combination of the above things.
\end{description}

\item[date(date:string)] gives a hint about the date the patch was
created. Format should be day (three letters) space month (three
letters) space day of the month (two characters, leading space for
single digit days) space  hh:mm:ss space yyyy.

\item[package(name:string)] gives a hint about the name of the package
to the receiver. The receiver may demand a package name, or may take
it as a hint.

\item[caption(des:string)] provides more discussion about the 
nature of a change. Captions are placed into logs of changes in the
order they occur in the patch.

\end{description}

\subsection{File changing commands}

\begin{description}


\item[patch(des:string, filename:string, patch:string\{,
major:boolean\{, extdes:string\}\})]

Patches file filename with patch. The patch argument should be in a
format understandable by GNU patch. Major defaults to false; it should
be set to true to indicate a major change to the file.

Extended descriptions are placed only into RCS logs, not into
general logs.


\item[replace(des:string, filename:string,
replacement:string\{, major:boolean, \{extdes:string\}\})]

Replaces file filename with replacement. Major defaults to false; it
should be set to true to indicate a major change to the file.

Extended descriptions are placed only into RCS logs, not into
general logs.


\item[create(des:string, filename:string, contents:string \{,extdes:string\})]

Extended descriptions are placed only in to RCS logs, not in to
general logs.

\item[remove(des:string, filename:string)]

Remove a file. 

\item[move(des:string, from:string, to:string)]

\item[assert\_md5(filename:string, md5sum:string)]
checks the MD5 sum of a file and warns the person applying the patch
if the MD5 sum differs. This feature is for people paranoid about
incompatible changes to files. Typically, most patches will probably
not incorporate MD5 sums. A patch containing MD5 sums for all files it
modifies is descriptiond as paranoid. The md5sum should be represented
as a hexadecimal number.

\item[mkdir(des:string, directory:string)]

Create a directory. Only valid if all but the leaf directory in the
directory name exists, and the leaf directory does not yet exist.

\item[rmdir(des:string, directory:string)]

Remove directory. Only valid for empty directories.

\item[chmod(des:string, filename:string, permissions:string)]

Set filename to have permissions. Permissions should be a valid Unix
chmod specification, such as \texttt{+x}.

\end{description}

\subsection{Notes}

\begin{enumerate}
\item
By convention, the line after each command should be 
\begin{verbatim}
#end of ddiff command
\end{verbatim}

This makes patches more readable. Optionally, a line of hashes may
also be put in after each large patch to enhance readability.

\emph{The current version of dcheckin.py uses this as a hint to split
up large files. This is to work around what appears to be a python
bug. In very large patches (greater than about 300K), you must put a
few comments in for dcheckin.py to work. This is horrible and will be
tidied up soon. }

\item
By convention, the last line of a \texttt{dpatch} file should be:
\begin{verbatim}
#end
\end{verbatim}

\item
All the descriptions in patch files are embedded in a file called
\texttt{updates} in the master tree, which can be used to keep an eye
on what has changed in a file. To keep this file neat, the following
guidelines should be followed:

\begin{itemize}
\item Overviews go on a line by themselves, with a carriage added on
to the end. So the overview should not finish with a carriage
return. Lines in the overview should be 78 characters or less long.

\item Descriptions of directory creations, file creations and patches
are tacked on to the end of lines. They should therefore normally be
35 characters or less. If the filename of the object being created is
longer than 40 characters, the description should be correspondingly less.

\item Move descriptions go on a line by themselves; a carriage return
is tacked on to the end of the line.

\item Caption descriptions go on a line by themselves; a carriage
return
is tacked on to the end of the line.

\end{itemize}
The idea is to keep line lengths down to 78 characters in the updates file.

\end{enumerate}

\subsection{Examples}

\begin{verbatim}
author_email('dr10009@cam.ac.uk')
author_name('Dickon Reed')
overview('Create a new directory and place some source code there')

date("Thu Dec 10 13:13:07 1998")
mkdir("describme", "app/foo")
#end of ddiff command
create("An Hello world snippet", "app/foo/hello.c",
r"""printf("Hello World\N");
"""
)
assert_md5("glue/generic_blueprint.py", "7f0f6f4b9be37aecdcba7b0a63fea2f1")
patch("describeme", "glue/generic_blueprint.py",
r"""--- /usr/groups/pegasus/nemesis/release/glue/generic_blueprint.py	Fri Nov 27 16:59:50 1998
+++ glue/generic_blueprint.py	Wed Dec  9 16:02:45 1998
@@ -47,46 +47,6 @@
   value : 0,
 }),
 
-PosixProgram('IClock', {
-  associated_cpp_name : 'ICLOCK',
-  description : 'Nemesis application IClock',
-  env : {'contexts':32,'defstack':'2k','endpoints':128,'frames':64,'heap':'32k','kernel':0,'sysheap':'8k',},
-  path : 'app/iclock',
-  qos : {'extra':1,'latency':'20ms','period':'20ms','slice':'0ns',},
-  requires : ['WTime'],
-  section : 'Applications',
-  tweakability : 2,
-  type : 'quad',
-  value : 0,
-}),

 PosixProgram('atlantis', {
   associated_cpp_name : 'ATLANTIS',
   description : 'Nemesis application atlantis',
"""
)
#end of ddiff command
#end
\end{verbatim}

\end{document}






